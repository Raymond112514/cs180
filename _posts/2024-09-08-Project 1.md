---
layout: post
---

## Colorizing the Prokudin-Gorskii Photo Collection

Formally, let $I_1(x, y), I_2(x, y)$ denote the intensity at $(x, y)$. We want to estimate a translation $(\Delta x, \Delta y)$ such that the transformed image $I_1$ is as close as possible to $I_2$. In other words, we solve the optimization problem

$$\Delta x^*, \Delta y^* = \underset{\Delta x, \Delta y}{\text{argmin}} \sum_{x, y} (I_1(x+\Delta x, y+\Delta y) - I_2(x, y))^2$$

We can as well use other metrics such as mean absolute error or normalized cross correlation to measure the distance between the transformed image and the base image. For the rest of our work, we will be aligning the red and green to the blue channel. 

<div style="display: flex; justify-content: space-between;">
  <img src="{{ site.baseurl }}/assets/images/red_raw.png" alt="Image 1" style="width: 30%; height: auto;">
  <img src="{{ site.baseurl }}/assets/images/green_raw.png" alt="Image 2" style="width: 30%; height: auto;">
  <img src="{{ site.baseurl }}/assets/images/blue_raw.png" alt="Image 3" style="width: 30%; height: auto;">
</div>

### Exhaustive search

The naive way of solving the optimization problem is to optimize $(\Delta x, \Delta y)$ over some search window. We implemented an exhaustive search algorithm that searchs the optimal translation in the range $[-15, 15]\times [-15, 15]$. This method works well with small scale images like `cathedral`, `monastery` and `tobolsk`, which has size around $256\times 256$. 

<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
* {box-sizing: border-box}
.mySlides {display: none}
img {vertical-align: middle;}

/* Slideshow container */
.slideshow-container {
  max-width: 1000px;
  position: relative;
  margin: auto;
}

/* Container for side-by-side images */
.image-container {
  display: flex;                /* Use flexbox to arrange images side by side */
  justify-content: space-between; /* Ensure equal space between images */
  align-items: center;          /* Center images vertically if they have different heights */
}

/* Style for each side-by-side image */
.side-by-side-image {
  width: 48%;                   /* Adjust width as needed (less than 50% to fit both images in one row) */
  height: auto;                 /* Maintain aspect ratio */
  border: 2px solid #ccc;       /* Border around each image */
  box-sizing: border-box;       /* Include border in width calculation */
}

/* Next & previous buttons */
.prev, .next {
  cursor: pointer;
  position: absolute;
  top: 50%;
  width: auto;
  padding: 16px;
  margin-top: -22px;
  color: white;
  font-weight: bold;
  font-size: 18px;
  transition: 0.6s ease;
  border-radius: 0 3px 3px 0;
  user-select: none;
}

/* Position the "next button" to the right */
.next {
  right: 0;
  border-radius: 3px 0 0 3px;
}

/* On hover, add a black background color with a little bit see-through */
.prev:hover, .next:hover {
  background-color: rgba(0,0,0,0.8);
}

/* The dots/bullets/indicators */
.dot {
  cursor: pointer;
  height: 15px;
  width: 15px;
  margin: 0 2px;
  background-color: #bbb;
  border-radius: 50%;
  display: inline-block;
  transition: background-color 0.6s ease;
}

.active, .dot:hover {
  background-color: #717171;
}

/* Fading animation */
.fade {
  animation-name: fade;
  animation-duration: 1.5s;
}

@keyframes fade {
  from {opacity: .4} 
  to {opacity: 1}
}
</style>
</head>

<!-- First Slider -->
<div class="slideshow-container">

  <div class="mySlides fade">
    <div class="image-container">
      <img src="{{ site.baseurl }}/assets/images/raw_cathedral.png" class="side-by-side-image">
      <img src="{{ site.baseurl }}/assets/images/mse_cathedral.png" class="side-by-side-image">
    </div>
  </div>

  <div class="mySlides fade">
    <div class="image-container">
      <img src="{{ site.baseurl }}/assets/images/raw_monastery.png" class="side-by-side-image">
      <img src="{{ site.baseurl }}/assets/images/mse_monastery.png" class="side-by-side-image">
    </div>
  </div>

  <div class="mySlides fade">
    <div class="image-container">
      <img src="{{ site.baseurl }}/assets/images/raw_tobolsk.png" class="side-by-side-image">
      <img src="{{ site.baseurl }}/assets/images/mse_tobolsk.png" class="side-by-side-image">
    </div>
  </div>

  <a class="prev" onclick="plusSlides(-1)">❮</a>
  <a class="next" onclick="plusSlides(1)">❯</a>

</div>
<br>

<div style="text-align:center">
  <span class="dot" onclick="currentSlide(1)"></span> 
  <span class="dot" onclick="currentSlide(2)"></span> 
  <span class="dot" onclick="currentSlide(3)"></span> 
</div>


<script>
let slideIndex = 1;
showSlides(slideIndex);

// Next/previous controls
function plusSlides(n) {
  showSlides(slideIndex += n);
}

// Thumbnail image controls
function currentSlide(n) {
  showSlides(slideIndex = n);
}

function showSlides(n) {
  let i;
  let slides = document.getElementsByClassName("mySlides");
  let dots = document.getElementsByClassName("dot");
  if (n > slides.length) {slideIndex = 1} 
  if (n < 1) {slideIndex = slides.length}
  for (i = 0; i < slides.length; i++) {
    slides[i].style.display = "none"; 
  }
  for (i = 0; i < dots.length; i++) {
    dots[i].className = dots[i].className.replace(" active", "");
  }
  slides[slideIndex-1].style.display = "block"; 
  dots[slideIndex-1].className += " active";
}
</script>

However, when we use this algorithm to align high-resolution images with dimensions around $3000 \times 3000$ pixels, the performance worsens. One reason is that the search space $[-15, 15] \times [-15, 15]$ is too small. However, increasing the search space significantly prolongs the runtime, as the algorithm has quadratic complexity.

<div style="display: flex; justify-content: center; gap: 20px;">
  <img src="{{ site.baseurl }}/assets/images/raw_melons.jpg" alt="Image 1" style="width: 50%; height: auto;">
  <img src="{{ site.baseurl }}/assets/images/mse_melons.jpg" alt="Image 2" style="width: 50%; height: auto;">
</div>

### Multipyramid search

To increase the efficiency of the search, we can apply the algorithm on the pyramid representation of the images. In the pyramid representation, represent an image at multiple resolutions. This is done through repetitive subsampling. In this case, we can perform search on the low-resolution images and update the estimate as we move forward. 

In the implementation, we first create a Gaussian pyramid of the image, which performs a Gaussian blur before subsampling with factor of $2$ (this is done to avoid aliasing), until the image size is below $256\times 256$. Afterwards, we apply our search algorithm in the low-resolution image, say the predicted translation is $(\Delta x, \Delta y)$. In the next step, we perform search on the next image with search window being $[2\Delta x-\epsilon, 2\Delta x+\epsilon]\times [2\Delta y-\epsilon, 2\Delta y+\epsilon]$. In our experiment, $\epsilon$ is set to be $10$.





